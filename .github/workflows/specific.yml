name: AT
on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'tag'
        default: ''
      privacy-enhancements:
        description: 'pe'
        default: 'false'
      privacy-precompile:
        description: 'ppc'
        default: 'false'
      privacy-marker-transactions:
        description: 'pmt'
        default: 'false'
      name:
        description: 'Name'
        default: 'default'
      runs-on:
        description: 'Runs on tag'
        default: 'ubuntu-18.04'
      goq-image:
        description: 'GoQuorum image'
        default: 'ghcr.io/baptiste-b-pegasys/quorum:develop'
      tessera-image:
        description: 'Tessera image'
        default: 'ghcr.io/baptiste-b-pegasys/tessera:develop'
      force-build-docker:
        description: 'Set true to build the docker image'
        default: 'false'
jobs:
  condition:
    name: Prepare - ${{ github.event.inputs.name }}
    runs-on: ${{ github.event.inputs.runs-on }}
    outputs:
      should_run: '${{ steps.check.outputs.val }}'
      use_aws: '${{ steps.check.outputs.useAws }}'
      infra: '${{ steps.check.outputs.infra }}'
    steps:
      - name: Check
        id: check
        run: |
          val="false"
          if [ \( "${{ github.event_name }}" == "schedule" -a "${{ secrets.SCHEDULE_RUN }}" != "disable" \) -o "${{ github.event_name }}" != "schedule" ]; then
            val="true"
          fi
          if [ "$val" == "false" ]; then
            echo "::warning ::Runs are conditionally skipped"
          fi
          useAws="true"
          infraName="AWS"
          if [ "${{ secrets.AWS_ACCESS_KEY_ID }}" == "" ] || [ "${{ github.event_name }}" == "pull_request" ] || [ "${{ secrets.DISABLE_AWS }}" == "true" ]; then
            useAws="false"
            infraName="GithubActionsVM"
          fi
          echo "::warning ::Networks are provisioned using $infraName infrastructure"
          echo "::set-output name=val::$val"
          echo "::set-output name=useAws::$useAws"
          echo "::set-output name=infra::$infraName"
  docker-build:
    name: 'Build Docker image'
    if: needs.condition.outputs.should_run == 'true'
    needs:
      - condition
    runs-on: ${{ github.event.inputs.runs-on }}
    outputs:
      output_dir: '${{ steps.prepare.outputs.output_dir }}'
      output_file: '${{ steps.prepare.outputs.output_file }}'
      image_file: '${{ steps.prepare.outputs.image_file }}'
      image_name: '${{ steps.prepare.outputs.image_name }}'
    steps:
      - name: 'Prepare'
        id: prepare
        run: |
          output_dir=${{ runner.temp }}/docker
          mkdir -p $output_dir
          echo "::set-output name=output_dir::$output_dir"
          echo "::set-output name=output_file::$output_dir/acctests.tar.gz"
          echo "::set-output name=image_file::acctests.tar"
          echo "::set-output name=image_name::quorumengineering/acctests:gh"
      - name: 'Cache docker image'
        id: cache-image
        uses: actions/cache@v2
        with:
          path: ${{ steps.prepare.outputs.output_dir }}
          key: ${{ github.sha }}
      - name: 'Check out project files'
        if: github.event.inputs.force-build-docker == 'true' || steps.cache-image.outputs.cache-hit != 'true'
        uses: actions/checkout@v2
      - name: 'Build docker image'
        if: github.event.inputs.force-build-docker == 'true' || steps.cache-image.outputs.cache-hit != 'true'
        id: build
        run: |
          docker build -t ${{ steps.prepare.outputs.image_name }} .
          docker save ${{ steps.prepare.outputs.image_name }} > ${{ steps.prepare.outputs.image_file }}
          tar cfvz ${{ steps.prepare.outputs.output_file }} ${{ steps.prepare.outputs.image_file }}
  run:
    # This workflow uses tag expression and its sha256 hash to aggregate test results
    # from each execution. It is important that the job name has tag expression in the
    # suffix and encapsulated within parathensis
    name: ${{ github.event.inputs.tag }}
    if: needs.condition.outputs.should_run == 'true'
    needs:
      - condition
      - docker-build      
    runs-on: ${{ github.event.inputs.runs-on }}
    steps:
      - name: 'Download docker image'
        uses: actions/cache@v2
        with:
          path: ${{ needs.docker-build.outputs.output_dir }}
          key: ${{ github.sha }}
      - name: 'Prepare environment'
        id: setup
        run: |
          tar xfvz ${{ needs.docker-build.outputs.output_file }}
          docker load --input ${{ needs.docker-build.outputs.image_file }}
          tagKey=$(echo -n "${{ github.event.inputs.tag }}" | shasum --algorithm=256 | awk '{print $1}')
          mvnArg=""
          dockerEnv="--network host -v /var/run/docker.sock:/var/run/docker.sock"
          local_image="true"
          dockerEnvFile=${{ runner.temp }}/env.list
          # now we check if we should use the custom docker images in this repo
          gitref_path="${{ github.ref }}"
          gitref_path=${gitref_path/refs\/heads\//} # for refs/heads/my-branch
          echo "${{ github.token }}" | docker login https://docker.pkg.github.com -u ${{ github.repository_owner }} --password-stdin
          echo "${{ github.token }}" | docker login ghcr.io -u ${{ github.repository_owner }} --password-stdin
          quorum_docker_image=$(echo "${{ github.event.inputs.goq-image }}" | tr '[:upper:]' '[:lower:]' )
          tessera_docker_image=$(echo "${{ github.event.inputs.tessera-image }}" | tr '[:upper:]' '[:lower:]')
          has_quorum_docker_image=$(docker pull $quorum_docker_image >/dev/null 2>&1; echo $?)
          has_tessera_docker_image=$(docker pull $tessera_docker_image >/dev/null 2>&1; echo $?)
          echo "$quorum_docker_image: $has_quorum_docker_image"
          echo "$tessera_docker_image: $has_tessera_docker_image"
          if [ $has_quorum_docker_image -eq 0 ]; then
            echo "::warning ::Using $quorum_docker_image"
            echo "TF_VAR_quorum_docker_image={name=\"$quorum_docker_image\", local=$local_image}" >> $dockerEnvFile
            docker pull $quorum_docker_image
          fi
          if [ $has_tessera_docker_image -eq 0 ]; then
            echo "::warning ::Using $tessera_docker_image"
            echo "TF_VAR_tessera_docker_image={name=\"$tessera_docker_image\", local=$local_image}" >> $dockerEnvFile
            docker pull $tessera_docker_image
          fi
          if [ $has_quorum_docker_image -eq 0 ] || [ $has_tessera_docker_image -eq 0 ]; then
            echo "TF_VAR_docker_registry=[{name=\"docker.pkg.github.com\", username=\"${{ github.repository_owner }}\", password=\"${{ github.token }}\"}]" >> $dockerEnvFile
          fi
          echo "TF_VAR_privacy_enhancements={block=0, enabled=${{ github.event.inputs.privacy-enhancements }}}" >> $dockerEnvFile
          echo "TF_VAR_privacy_precompile={block=0, enabled=${{ github.event.inputs.privacy-precompile }}}" >> $dockerEnvFile
          echo "TF_VAR_privacy_marker_transactions=${{ github.event.inputs.privacy-marker-transactions }}" >> $dockerEnvFile
          echo "::set-output name=tag::$tagKey"
          echo "::set-output name=mvnArg::$mvnArg"
          echo "::set-output name=dockerEnv::$dockerEnv"
          echo "::set-output name=outputDir::${{ runner.temp }}"
          echo "::set-output name=dockerEnvFile::$dockerEnvFile"
      - name: 'Run tests using ${{ needs.condition.outputs.infra }}'
        run: |
          # we don't remove the container after run as we need to clean up the infra if used
          docker run \
              --name acctests-run ${{ steps.setup.outputs.dockerEnv }} \
              -v ${{ steps.setup.outputs.outputDir }}:${{ steps.setup.outputs.outputDir }} \
              --env-file ${{ steps.setup.outputs.dockerEnvFile }} \
              ${{ needs.docker-build.outputs.image_name }} test \
                -PgaugeFailSafe \
                -Pauto \
                -Dtags="${{ github.event.inputs.tag }}" ${{ steps.setup.outputs.mvnArg }} \
                -Dauto.outputDir=${{ steps.setup.outputs.outputDir }} \
                -Dauto.jobid=${{ steps.setup.outputs.tag }}
      - name: 'Failure info'
        if: ${{ failure() }}
        run: |
            echo "acceptance tests failures"
            docker images
            docker ps -a
            for containerId in $(docker ps -qa); do echo "container: $containerId"; docker container inspect $containerId; docker container logs $containerId; done
      - name: 'Read test report'
        if: always()
        run: |
          failuresRaw="$(cat ${{ steps.setup.outputs.outputDir }}/failures.txt | jq -r '.[] | @base64')"
          SAVEIFS=$IFS   # Save current IFS
          IFS=$'\n'      # Change IFS to new line
          failures=($failuresRaw) # split to array
          IFS=$SAVEIFS   # Restore IFS
          for (( i=0; i<${#failures[@]}; i++ ))
          do
            row=${failures[$i]}
            _jq() {
                echo ${row} | base64 --decode | jq -r ${1}
            }
            echo "$(_jq '.file'): $(_jq '.message')"
            echo "::error file=$(_jq '.file'),line=$(_jq '.line'),col=$(_jq '.col')::$(_jq '.message')"
          done
          cat ${{ steps.setup.outputs.outputDir}}/summary.txt
