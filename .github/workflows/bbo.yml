name: Run Acceptance Tests
on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'GoQuorum branch'
        default: 'develop'
      tessera-image:
        description: 'Tessera image'
        default: 'ghcr.io/baptiste-b-pegasys/tessera:develop'
      force-build-docker:
        description: 'Set true to build the docker image'
        default: 'false'
jobs:
  condition:
    name: Evaluate workflow run conditions
    runs-on: ubuntu-18.04
    outputs:
      should_run: '${{ steps.check.outputs.val }}'
      use_aws: '${{ steps.check.outputs.useAws }}'
      infra: '${{ steps.check.outputs.infra }}'
    steps:
      - name: Check
        id: check
        run: |
          val="false"
          if [ \( "${{ github.event_name }}" == "schedule" -a "${{ secrets.SCHEDULE_RUN }}" != "disable" \) -o "${{ github.event_name }}" != "schedule" ]; then
            val="true"
          fi
          if [ "$val" == "false" ]; then
            echo "::warning ::Runs are conditionally skipped"
          fi
          useAws="true"
          infraName="AWS"
          if [ "${{ secrets.AWS_ACCESS_KEY_ID }}" == "" ] || [ "${{ github.event_name }}" == "pull_request" ] || [ "${{ secrets.DISABLE_AWS }}" == "true" ]; then
            useAws="false"
            infraName="GithubActionsVM"
          fi
          echo "::warning ::Networks are provisioned using $infraName infrastructure"
          echo "::set-output name=val::$val"
          echo "::set-output name=useAws::$useAws"
          echo "::set-output name=infra::$infraName"
  docker-build:
    name: 'Build Docker image'
    if: needs.condition.outputs.should_run == 'true'
    needs:
      - condition
    runs-on: ubuntu-18.04
    outputs:
      output_dir: '${{ steps.prepare.outputs.output_dir }}'
      output_file: '${{ steps.prepare.outputs.output_file }}'
      image_file: '${{ steps.prepare.outputs.image_file }}'
      image_name: '${{ steps.prepare.outputs.image_name }}'
    steps:
      - name: 'Prepare'
        id: prepare
        run: |
          output_dir=${{ runner.temp }}/docker
          mkdir -p $output_dir
          echo "::set-output name=output_dir::$output_dir"
          echo "::set-output name=output_file::$output_dir/acctests.tar.gz"
          echo "::set-output name=image_file::acctests.tar"
          echo "::set-output name=image_name::quorumengineering/acctests:gh"
      - name: 'Cache docker image'
        id: cache-image
        uses: actions/cache@v2
        with:
          path: ${{ steps.prepare.outputs.output_dir }}
          key: ${{ github.sha }}
      - name: 'Check out project files'
        if: github.event.inputs.force-build-docker == 'true' || steps.cache-image.outputs.cache-hit != 'true'
        uses: actions/checkout@v2
      - name: 'Build docker image'
        if: github.event.inputs.force-build-docker == 'true' || steps.cache-image.outputs.cache-hit != 'true'
        id: build
        run: |
          docker build -t ${{ steps.prepare.outputs.image_name }} .
          docker save ${{ steps.prepare.outputs.image_name }} > ${{ steps.prepare.outputs.image_file }}
          tar cfvz ${{ steps.prepare.outputs.output_file }} ${{ steps.prepare.outputs.image_file }}
  run:
    # This workflow uses tag expression and its sha256 hash to aggregate test results
    # from each execution. It is important that the job name has tag expression in the
    # suffix and encapsulated within parathensis
    name: Tests tagged with (${{ matrix.tag }})
    if: needs.condition.outputs.should_run == 'true'
    needs:
      - condition
      - docker-build
    strategy:
      fail-fast: false
      matrix:
        # list of tag expression being executed in parallel
        tag:
          - 'basic || basic-raft || (advanced && raft) || networks/typical::raft'
          - 'basic || basic-istanbul || (advanced && istanbul) || networks/typical::istanbul'
          - 'gcmode && block-sync && networks/template::raft-3plus1'
          - 'gcmode && block-sync && networks/template::istanbul-3plus1'
          - 'learner-peer-management || raftdnsenable && networks/template::raft-3plus1'
          - 'validator-management && networks/template::istanbul-3plus1'
          - 'basic || basic-raft || (advanced && raft) || networks/plugins::raft'
          - 'basic || basic-istanbul || (advanced && istanbul) || networks/plugins::istanbul'
          - 'basic || basic-raft || (advanced && raft) || networks/plugins::raft-account-plugin-hashicorp-vault'
          - 'basic || basic-istanbul || (advanced && istanbul) || networks/plugins::istanbul-account-plugin-hashicorp-vault'
          - 'basic-rpc-security || networks/plugins::raft-rpc-security'
          - 'basic-rpc-security || networks/plugins::istanbul-rpc-security'
          - 'migration && networks/template::raft-4nodes'
          - 'migration && networks/template::istanbul-4nodes'
          - 'migration && networks/template::raft-4nodes-ancientdb'
          - 'migration && networks/template::istanbul-4nodes-ancientdb'
          - 'permissions-v1 && networks/template::raft-3plus1'
          - 'permissions-v2 && networks/template::raft-3plus1'
          - 'privacy-enhancements-upgrade || networks/template::raft-4nodes-pe'
          - 'privacy-enhancements-upgrade || networks/template::istanbul-4nodes-pe'
          - 'multitenancy && networks/plugins::raft-multitenancy'
          - 'basic || basic-raft || (advanced && raft) || networks/typical::raft-simple-mps'
          - 'basic || basic-istanbul || (advanced && istanbul) || networks/typical::istanbul-simple-mps'
          - 'basic || networks/typical::raftmps'
          - 'basic || networks/typical::istanbulmps'
          - 'mps-upgrade-txtrace || networks/template::raft-4nodes-mps'
          - 'mps-upgrade-txtrace || networks/template::istanbul-4nodes-mps'
          - '(basic && !nosupport && !mps && !spam && !eth-api-signed && !privacy-enhancements-disabled && !graphql && !async && !extension && !storage-root && !get-quorum-payload && !personal-api-signed) || networks/typical-besu::ibft2'
        privacy-enhancements:
          - 'false'
        include:
          - tag: '(basic && !privacy-enhancements-disabled) || privacy-enhancements || basic-raft || (advanced && raft) || networks/typical::raft'
            privacy-enhancements: 'true'
          - tag: '(basic && !privacy-enhancements-disabled) || privacy-enhancements || basic-istanbul || (advanced && istanbul) || networks/typical::istanbul'
            privacy-enhancements: 'true'
    runs-on: ubuntu-18.04
    steps:
      - name: 'Download docker image'
        uses: actions/cache@v2
        with:
          path: ${{ needs.docker-build.outputs.output_dir }}
          key: ${{ github.sha }}
      - name: 'Prepare environment'
        id: setup
        run: |
          tar xfvz ${{ needs.docker-build.outputs.output_file }}
          docker load --input ${{ needs.docker-build.outputs.image_file }}
          tagKey=$(echo -n "${{ matrix.tag }}" | shasum --algorithm=256 | awk '{print $1}')
          mvnArg=""
          dockerEnv="--network host -v /var/run/docker.sock:/var/run/docker.sock"
          local_image="true"
          dockerEnvFile=${{ runner.temp }}/env.list
          # now we check if we should use the custom docker images in this repo
          gitref_path="${{ github.ref }}"
          gitref_path=${gitref_path/refs\/heads\//} # for refs/heads/my-branch
          echo "${{ github.token }}" | docker login https://docker.pkg.github.com -u ${{ github.repository_owner }} --password-stdin
          echo "${{ github.token }}" | docker login ghcr.io -u ${{ github.repository_owner }} --password-stdin
          quorum_docker_image=$(echo "ghcr.io/${{ github.repository_owner }}/quorum-master:${{ github.event.inputs.branch }}" | tr '[:upper:]' '[:lower:]' )
          tessera_docker_image=$(echo "${{ github.event.inputs.tessera-image }}" | tr '[:upper:]' '[:lower:]')
          has_quorum_docker_image=$(docker pull $quorum_docker_image >/dev/null 2>&1; echo $?)
          has_tessera_docker_image=$(docker pull $tessera_docker_image >/dev/null 2>&1; echo $?)
          echo "$quorum_docker_image: $has_quorum_docker_image"
          echo "$tessera_docker_image: $has_tessera_docker_image"
          if [ $has_quorum_docker_image -eq 0 ]; then
            echo "::warning ::Using $quorum_docker_image"
            echo "TF_VAR_quorum_docker_image={name=\"$quorum_docker_image\", local=$local_image}" >> $dockerEnvFile
            docker pull $quorum_docker_image
          fi
          if [ $has_tessera_docker_image -eq 0 ]; then
            echo "::warning ::Using $tessera_docker_image"
            echo "TF_VAR_tessera_docker_image={name=\"$tessera_docker_image\", local=$local_image}" >> $dockerEnvFile
            docker pull $tessera_docker_image
          fi
          if [ $has_quorum_docker_image -eq 0 ] || [ $has_tessera_docker_image -eq 0 ]; then
            echo "TF_VAR_docker_registry=[{name=\"docker.pkg.github.com\", username=\"${{ github.repository_owner }}\", password=\"${{ github.token }}\"}]" >> $dockerEnvFile
          fi
          echo "TF_VAR_privacy_enhancements={block=0, enabled=${{ matrix.privacy-enhancements}}}" >> $dockerEnvFile
          echo "::set-output name=tag::$tagKey"
          echo "::set-output name=mvnArg::$mvnArg"
          echo "::set-output name=dockerEnv::$dockerEnv"
          echo "::set-output name=outputDir::${{ runner.temp }}"
          echo "::set-output name=dockerEnvFile::$dockerEnvFile"
      - name: 'Run tests using ${{ needs.condition.outputs.infra }}'
        run: |
          # we don't remove the container after run as we need to clean up the infra if used
          docker run \
              --name acctests-run ${{ steps.setup.outputs.dockerEnv }} \
              -v ${{ steps.setup.outputs.outputDir }}:${{ steps.setup.outputs.outputDir }} \
              --env-file ${{ steps.setup.outputs.dockerEnvFile }} \
              ${{ needs.docker-build.outputs.image_name }} test \
                -PgaugeFailSafe \
                -Pauto \
                -Dtags="${{ matrix.tag }}" ${{ steps.setup.outputs.mvnArg }} \
                -Dauto.outputDir=${{ steps.setup.outputs.outputDir }} \
                -Dauto.jobid=${{ steps.setup.outputs.tag }}
      - name: 'Failure info'
        if: ${{ failure() }}
        run: |
            echo "acceptance tests failures"
            docker images
            docker ps -a
            for containerId in $(docker ps -qa); do echo "container: $containerId"; docker container inspect $containerId; docker container logs $containerId; done
      - name: 'Read test report'
        if: always()
        run: |
          failuresRaw="$(cat ${{ steps.setup.outputs.outputDir }}/failures.txt | jq -r '.[] | @base64')"
          SAVEIFS=$IFS   # Save current IFS
          IFS=$'\n'      # Change IFS to new line
          failures=($failuresRaw) # split to array
          IFS=$SAVEIFS   # Restore IFS
          for (( i=0; i<${#failures[@]}; i++ ))
          do
            row=${failures[$i]}
            _jq() {
                echo ${row} | base64 --decode | jq -r ${1}
            }
            echo "$(_jq '.file'): $(_jq '.message')"
            echo "::error file=$(_jq '.file'),line=$(_jq '.line'),col=$(_jq '.col')::$(_jq '.message')"
          done
          cat ${{ steps.setup.outputs.outputDir}}/summary.txt
      - name: 'Upload test report'
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: testreport-${{ steps.setup.outputs.tag }}
          path: ${{ steps.setup.outputs.outputDir }}/*.* # only files not directory